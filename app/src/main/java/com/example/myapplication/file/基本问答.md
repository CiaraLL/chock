# Fragment和Activity数据互传

## 1.Activity 给 fragment 传数据

setArguments(Bundle bundle)

## 2.fragment 给 Activity 传数据

广播/eventBus/自定义接口

## 3.activity给Actiivty

### startactivity的时候使用intent

    intent.putExtra（new Bundle）一般复杂数据
    intent.putExtra（序列化对象）数据大的

## 4.fragment给Fragment

https://blog.csdn.net/sinat_31057219/article/details/77743704

### set方法

1、在(接收方)的fragment中设置setData方法

        public void setData(String string) {
            bt_main.setText(string);
        }

2、在(发送方)获取(接收方)的fragment，并调用setData方法

    // 方法一：在MainFragment中设置一个setData()方法，在方法中设置更改按钮名称
    MainFragment mainFragment = (MainFragment)getActivity().getSupportFragmentManager().findFragmentByTag("mainFragment");
    mainFragment.setData(mDatas.get(position));

    被发送方设置setdata方法
    发送方通过getSurpportManager获取 ，设置listener

### 自定义接口回调

    发送方实现一个listeners传递给接受方，接收方取出数据使用；

### eventBus

# Android 如何传递参数给H5

## 1.使用URL参数传递 ,最简单的方式是通过URL参数将数据传递给H5页面。

Android可以通过WebView的loadUrl()方法加载带有参数的URL，H5页面可以通过解析URL来获取参数值。
首先，在Android端构造带有参数的URL，然后加载该URL到WebView中：

        WebView webView = findViewById(R.id.webView); 
        String param1 = "value1";
        String param2 = "value2";
        String url = " + param1 + "&param2=" + param2;
        webView.loadUrl(url);

在H5页面中，可以通过解析URL获取参数值：

        function getParameterByName(name, url) {
        if (!url) url = window.location.href;
        name = name.replace(/[[\]]/g, "\\$&");
        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, " "));
        }
    
        var param1 = getParameterByName('param1');
        var param2 = getParameterByName('param2');

## 2.使用JavascriptInterface传递参数

H5调用Android的方法

另一种方式是通过JavascriptInterface在Android端和H5页面之间建立桥梁，实现双向通信。
Android可以通过addJavascriptInterface()方法将一个Java对象注入到WebView中，H5页面可以通过该对象调用Android端的方法获取参数值。

首先，在Android端创建一个Java对象，并将其注入到WebView中：
h5给Android发：        
1.自定义一个MyJavascriptInterface类，并且在类中实现接受到消息之后的操作。
2.创建MyJavascriptInterface类对象，将对象传给webView.addJavascriptInterface(myJavascriptInterface, "Android")

       public class MyJavascriptInterface {
            @JavascriptInterface
            public String sendData(string str) {
               //处理从h5页面参数获取到的数据

            }

            @JavascriptInterface
            public String getDeviceInfo() {
               return stationPoints;
            } 

             @JavascriptInterface
             public String getAllDefect() {
                  //给h5发送复杂数据用Gson
                 return new Gson().toJson(report.getAppDefectDtos());
             }
       }
       WebView webView = findViewById(R.id.webView);
       webView.getSettings().setJavaScriptEnabled(true);
       MyJavascriptInterface myJavascriptInterface = new MyJavascriptInterface();
       webView.addJavascriptInterface(myJavascriptInterface, "Android");
       webView.loadUrl()

在h5页面中可以调用Android给的接口：
      
      //发简单数据
      function sendData(str){
         Android.sendData(str)
      }

      //h5收数据
      var deviceInfo = JSON.parse(window.android.getDeviceInfo());
      
      //给h5收复杂数据用json
      let JsondefectData = JSON.parse(defectData);


## 3.使用WebView的evaluateJavascript方法传递参数

另一种方式是使用WebView的evaluateJavascript()方法，在Android端直接执行JavaScript代码，并传递参数给H5页面。

Android调用了h5的callJS()方法，然后收到了一个返回值

      mWebView.evaluateJavascript（"javascript:callJS()", new ValueCallback<String>() {
        @Override
        public void onReceiveValue(String value) {
            //此处为 js 返回的结果
        }
      });

在H5页面中，可以定义一个receiveParams()函数来接收参数：

       function receiveParams(param1, param2) {
         // 处理接收到的参数...
       }


# 谈一谈获取View宽高的几种方法?
1. OnGlobalLayoutListener获取      
   ViewTreeObserver.addOnGlobalLayoutListener() 监听View的onLayout()绘制过程，一旦layout触发变化，立即回调onLayoutChange方法。
   在布局发生改变或者某个视图的可视状态发生改变时调用该事件，会被多次调用，
   注意，使用完也要主要调用removeOnGlobalListener()方法移除监听事件。避免后续每一次发生全局View变化均触发该事件，影响性能。

        ViewTreeObserver vto = view.getViewTreeObserver();
            vto.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                view.getViewTreeObserver().removeGlobalOnLayoutListener(this);
                Log.i(TAG, "width: " + view.getWidth());
                Log.i(TAG, "height: " + view.getHeight());
            }
        });
2. OnPreDrawListener获取
   在视图将要绘制时调用该监听事件，会被调用多次，因此获取到视图的宽度和高度后要移除该监听事件。这同样是 ViewTreeObserver 的接口。
   OnPreDrawListener是在draw之前的回调，此时已经 layout 过，可以获取到 View 的宽高值。OnPreDrawListener还可以控制绘制流程，返回false的时候就取消当前绘制流程，View会再schedule下一次绘制：

       getWindow().getDecorView().getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
           @Override
           public boolean onPreDraw() {
               getTextWidthHeight();
               getWindow().getDecorView().getViewTreeObserver().removeOnPreDrawListener(this);
               return false;
           }
       });

3. OnLayoutChangeListener获取   
   在视图的 layout 改变时调用该事件，会被多次调用，因此需要在获取到视图的宽度和高度后执行 remove 方法移除该监听事件。

        view.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
           @Override
           public void onLayoutChange(View v, int left, int top, int right, int bottom,int oldLeft, int oldTop, int oldRight, int oldBottom) {
                view.removeOnLayoutChangeListener(this);
                int w = view.getWidth();
                int h = view.getHeight();
          }
       });

4. 重写View的onSizeChanged，该方法会在onCreate之后，onDraw之前调用
   在视图的大小发生改变时调用该方法，会被多次调用，因此获取到宽度和高度后需要考虑禁用掉代码。该实现方法需要继承 View，且多次被调用，不建议使用。

        @Override
        protected void onSizeChanged(int w, int h, int oldw, int oldh) {
            super.onSizeChanged(w, h, oldw, oldh);
            Log.i("TAG", "width = " + getWidth() + "height = " + getHeight());
        }

5. 使用View.post()方法
   利用Handler通信机制，发送一个Runnable到MessageQueue中，当View布局处理完成时，自动发送消息，通知UI进程。借此机制，巧妙获取View的高宽属性，代码简洁，相比ViewTreeObserver监听处理，还不需要手动移除观察者监听事件。

        view.post(new Runnable() {
                @Override
                public void run() {
                    int width = view.getWidth();
                    int measuredWidth = view.getMeasuredWidth();
                    Log.i(TAG, "width: " + width);
                    Log.i(TAG, "measuredWidth: " + measuredWidth);
                }
            });


# 自定义View步骤

## 1. 自定义单一View

1. 继承现有的View类或其子类，如View、ImageView等。
2. 重写onMeasure()方法，在该方法中设定自定义View的宽高。
3. 重写onDraw()方法，在该方法中绘制自定义的View。Canvas决定要去画什么；Paint决定怎么画
4. 考虑支持自定义属性，通过重写构造方法并获取自定义属性值。在init方法中，可以初始化画笔、颜色、文本等属性。LayoutParams，
5. 如果需要响应用户的触摸事件、点击等操作，需要重写onTouchEvent()方法。
6. 注意调用invalidate()方法，触发重绘操作。

       public class MyCustomView extends View {
         public MyCustomView(Context context) {
            super(context);
        }
        public MyCustomView(Context context, AttributeSet attrs) {
            super(context, attrs);
        }
        public MyCustomView(Context context, AttributeSet attrs, int defStyleAttr) {
            super(context, attrs, defStyleAttr);
        }

        @Override
        public boolean onTouchEvent(MotionEvent event) {
        // 处理触摸事件
        switch (event.getAction()) {
           case MotionEvent.ACTION_DOWN:
           // 处理按下事件
           break;
           case MotionEvent.ACTION_MOVE:
            // 处理移动事件
            break;
            case MotionEvent.ACTION_UP:
            // 处理抬起事件
            break;
          }
           return true;
        }

        @Override
        protected void onDraw(Canvas canvas) {
            super.onDraw(canvas);
    
            // 在画布上绘制一个红色的矩形
            Paint paint = new Paint();
            paint.setColor(Color.RED);
            canvas.drawRect(0, 0, getWidth(), getHeight(), paint);
        }
        }

event.getX():表示的是触摸的点距离自身左边界的距离           
event.getY():表示的是触摸的点距离自身上边界的距离              
event.getRawX:表示的是触摸点距离屏幕左边界的距离             
event.getRawY:表示的是触摸点距离屏幕上边界的距离               
 
View.getWidth():表示的是当前控件的宽度，即getRight()-getLeft()       
View.getHeight()：表示的是当前控件的高度，即getBottom()-getTop()         
View.getTop():子View的顶部到父View顶部的距离         
View.getRight():子View的右边界到父View的左边界的距离       
View.getBottom():子View的底部到父View的顶部的距离       
View.getLeft():子View的左边界到父View的左边界的距离         
View.getTranslationX()计算的是该View在X轴的偏移量。初始值为0，向左偏移值为负，向右偏移值为正。       
View.getTranslationY()计算的是该View在Y轴的偏移量。初始值为0，向上偏移为负，向下偏移为证。     

注意：
1. `invalidate()`方法会触发`onDraw()`方法的调用，用于重绘自定义View的内容；          
2. `requestLayout()`方法会触发`onMeasure()`和`onLayout()`方法的调用，用于重新测量和布局自定义ViewGroup中的子View。            

## 2. 自定义ViewGroup：

1. 继承现有的ViewGroup类如LinearLayout、RelativeLayout等。
2. 重写onMeasure()方法，测量自定义ViewGroup及其子View的尺寸。
3. 重写onLayout()方法，指定子View的位置。
4. 考虑支持自定义属性，通过重写构造方法并获取自定义属性值。比如layoutParms等
5. 如果需要响应触摸事件、点击等操作，需要重写onTouchEvent()方法。
6. 注意子View的绘制顺序，可以使用getChildAt()和getChildCount()方法获取子View。

一般情况下，当自定义View需要处理触摸事件时，需要重写onTouchEvent()
方法。在该方法中可以根据MotionEvent的动作类型，如ACTION_DOWN、ACTION_MOVE、ACTION_UP等，执行相应的操作。

    public class MyCustomViewGroup extends ViewGroup {
    
        public MyCustomViewGroup(Context context) {
            super(context);
        }
    
        public MyCustomViewGroup(Context context, AttributeSet attrs) {
            super(context, attrs);
        }
    
        public MyCustomViewGroup(Context context, AttributeSet attrs, int defStyleAttr) {
            super(context, attrs, defStyleAttr);
        }
    
        @Override
        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
            // 测量ViewGroup的尺寸，需要考虑子View的大小及MeasureSpec
    
            // 测量子View的尺寸
            measureChildren(widthMeasureSpec, heightMeasureSpec);
    
            // 获取ViewGroup的宽度测量模式和大小
            int widthMode = MeasureSpec.getMode(widthMeasureSpec);
            int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    
            // 获取ViewGroup的高度测量模式和大小
            int heightMode = MeasureSpec.getMode(heightMeasureSpec);
            int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    
            // 计算ViewGroup的宽度
            int width = 0;
            if (widthMode == MeasureSpec.EXACTLY) {
                // 宽度测量模式为精确模式时，直接使用设置的宽度
                width = widthSize;
            } else {
                // 宽度测量模式为包裹内容或未指定模式时，计算所有子View的宽度总和作为ViewGroup的宽度
                for (int i = 0; i < getChildCount(); i++) {
                    View child = getChildAt(i);
                    width += child.getMeasuredWidth();
                }
            }
    
            // 计算ViewGroup的高度（取最高的子View的高度作为ViewGroup的高度）
            int height = 0;
            if (heightMode == MeasureSpec.EXACTLY) {
                // 高度测量模式为精确模式时，直接使用设置的高度
                height = heightSize;
            } else {
                // 高度测量模式为包裹内容或未指定模式时，取最高的子View的高度作为ViewGroup的高度
                for (int i = 0; i < getChildCount(); i++) {
                    View child = getChildAt(i);
                    height = Math.max(height, child.getMeasuredHeight());
                }
            }
    
            // 设置ViewGroup的测量结果
            setMeasuredDimension(width, height);
        }
    
        @Override
        protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
            // 对子View进行布局
    
            int childLeft = 0;
            int childTop = 0;
    
            // 遍历子View进行布局
            for (int i = 0; i < getChildCount(); i++) {
                View child = getChildAt(i);
    
                // 获取子View的宽度和高度
                int childWidth = child.getMeasuredWidth();
                int childHeight = child.getMeasuredHeight();
    
                // 布局子View
                child.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight);
    
                // 更新下一个子View的left值
                childLeft += childWidth;
            }
        }
    }

自定义ViewGroup不需要重写`onDraw()`方法。
因为`onDraw()`方法是用于在`View`上进行绘制操作的，而`ViewGroup`是一个容器，它的主要作用是管理子View的布局和绘制。
所以，在自定义ViewGroup中，我们主要需要重写`onMeasure()`方法来测量子View的尺寸，并重写`onLayout()`
方法来布局子View的位置。而对于绘制操作，通常会由子View自己负责。

# LinearLayout和RelativeLayout性能对比
RelativeLayout 会对子 View 做两次 measure。因为 RelativeLayout 中子 View 的排列方式是基于彼此的依赖关系，而这个依赖关系可能和布局中View的顺序并不相同，在确定每个子 View 的位置的时候，就需要先给所有的子View排序一下。所以需要横向纵向分别测量。

RelativeLayout会让子View调用2次onMeasure，而 LinearLayout 在没有 weight 时，只会调用1次onMeasure（如果 LinearLayout 有 weight 属性时，也会调用两次 onMeasure ）；因此LinearLayout 性能要高于 RelativeLayout 的性能，在实际操作时可以用 LinearLayout 完成，尽量用 LinearLayout 不去用 RelativeLayout 。