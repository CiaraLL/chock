# Fragment和Activity数据互传

## 1.Activity 给 fragment 传数据

setArguments(Bundle bundle)

## 2.fragment 给 Activity 传数据

广播/eventBus/自定义接口

## 3.activity给Actiivty

### startactivity的时候使用intent

    intent.putExtra（new Bundle）一般复杂数据
    intent.putExtra（序列化对象）数据大的

## 4.fragment给Fragment

https://blog.csdn.net/sinat_31057219/article/details/77743704

### set方法

1、在(接收方)的fragment中设置setData方法

        public void setData(String string) {
            bt_main.setText(string);
        }

2、在(发送方)获取(接收方)的fragment，并调用setData方法

    // 方法一：在MainFragment中设置一个setData()方法，在方法中设置更改按钮名称
    MainFragment mainFragment = (MainFragment)getActivity().getSupportFragmentManager().findFragmentByTag("mainFragment");
    mainFragment.setData(mDatas.get(position));

    被发送方设置setdata方法
    发送方通过getSurpportManager获取 ，设置listener

### 自定义接口回调

    发送方实现一个listeners传递给接受方，接收方取出数据使用；

### eventBus

# Android 如何传递参数给H5

## 1.使用URL参数传递 ,最简单的方式是通过URL参数将数据传递给H5页面。

Android可以通过WebView的loadUrl()方法加载带有参数的URL，H5页面可以通过解析URL来获取参数值。
首先，在Android端构造带有参数的URL，然后加载该URL到WebView中：

        WebView webView = findViewById(R.id.webView); 
        String param1 = "value1";
        String param2 = "value2";
        String url = " + param1 + "&param2=" + param2;
        webView.loadUrl(url);

在H5页面中，可以通过解析URL获取参数值：

        function getParameterByName(name, url) {
        if (!url) url = window.location.href;
        name = name.replace(/[[\]]/g, "\\$&");
        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, " "));
        }
    
        var param1 = getParameterByName('param1');
        var param2 = getParameterByName('param2');

## 2.使用JavascriptInterface传递参数

H5调用Android的方法

另一种方式是通过JavascriptInterface在Android端和H5页面之间建立桥梁，实现双向通信。
Android可以通过addJavascriptInterface()方法将一个Java对象注入到WebView中，H5页面可以通过该对象调用Android端的方法获取参数值。

首先，在Android端创建一个Java对象，并将其注入到WebView中：
h5给Android发：        
1.自定义一个MyJavascriptInterface类，并且在类中实现接受到消息之后的操作。
2.创建MyJavascriptInterface类对象，将对象传给webView.addJavascriptInterface(myJavascriptInterface, "Android")

       public class MyJavascriptInterface {
            @JavascriptInterface
            public String sendData(string str) {
               //处理从h5页面参数获取到的数据

            }

            @JavascriptInterface
            public String getDeviceInfo() {
               return stationPoints;
            } 

             @JavascriptInterface
             public String getAllDefect() {
                  //给h5发送复杂数据用Gson
                 return new Gson().toJson(report.getAppDefectDtos());
             }
       }
       WebView webView = findViewById(R.id.webView);
       webView.getSettings().setJavaScriptEnabled(true);
       MyJavascriptInterface myJavascriptInterface = new MyJavascriptInterface();
       webView.addJavascriptInterface(myJavascriptInterface, "Android");
       webView.loadUrl()

在h5页面中可以调用Android给的接口：
      
      //发简单数据
      function sendData(str){
         Android.sendData(str)
      }

      //h5收数据
      var deviceInfo = JSON.parse(window.android.getDeviceInfo());
      
      //给h5收复杂数据用json
      let JsondefectData = JSON.parse(defectData);


## 3.使用WebView的evaluateJavascript方法传递参数

另一种方式是使用WebView的evaluateJavascript()方法，在Android端直接执行JavaScript代码，并传递参数给H5页面。

Android调用了h5的callJS()方法，然后收到了一个返回值

      mWebView.evaluateJavascript（"javascript:callJS()", new ValueCallback<String>() {
        @Override
        public void onReceiveValue(String value) {
            //此处为 js 返回的结果
        }
      });

在H5页面中，可以定义一个receiveParams()函数来接收参数：

       function receiveParams(param1, param2) {
         // 处理接收到的参数...
       }


# 谈一谈获取View宽高的几种方法?
1. OnGlobalLayoutListener获取      
   ViewTreeObserver.addOnGlobalLayoutListener() 监听View的onLayout()绘制过程，一旦layout触发变化，立即回调onLayoutChange方法。
   在布局发生改变或者某个视图的可视状态发生改变时调用该事件，会被多次调用，
   注意，使用完也要主要调用removeOnGlobalListener()方法移除监听事件。避免后续每一次发生全局View变化均触发该事件，影响性能。

        ViewTreeObserver vto = view.getViewTreeObserver();
            vto.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                view.getViewTreeObserver().removeGlobalOnLayoutListener(this);
                Log.i(TAG, "width: " + view.getWidth());
                Log.i(TAG, "height: " + view.getHeight());
            }
        });
2. OnPreDrawListener获取
   在视图将要绘制时调用该监听事件，会被调用多次，因此获取到视图的宽度和高度后要移除该监听事件。这同样是 ViewTreeObserver 的接口。
   OnPreDrawListener是在draw之前的回调，此时已经 layout 过，可以获取到 View 的宽高值。OnPreDrawListener还可以控制绘制流程，返回false的时候就取消当前绘制流程，View会再schedule下一次绘制：

       getWindow().getDecorView().getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
           @Override
           public boolean onPreDraw() {
               getTextWidthHeight();
               getWindow().getDecorView().getViewTreeObserver().removeOnPreDrawListener(this);
               return false;
           }
       });

3. OnLayoutChangeListener获取   
   在视图的 layout 改变时调用该事件，会被多次调用，因此需要在获取到视图的宽度和高度后执行 remove 方法移除该监听事件。

        view.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
           @Override
           public void onLayoutChange(View v, int left, int top, int right, int bottom,int oldLeft, int oldTop, int oldRight, int oldBottom) {
                view.removeOnLayoutChangeListener(this);
                int w = view.getWidth();
                int h = view.getHeight();
          }
       });

4. 重写View的onSizeChanged，该方法会在onCreate之后，onDraw之前调用
   在视图的大小发生改变时调用该方法，会被多次调用，因此获取到宽度和高度后需要考虑禁用掉代码。该实现方法需要继承 View，且多次被调用，不建议使用。

        @Override
        protected void onSizeChanged(int w, int h, int oldw, int oldh) {
            super.onSizeChanged(w, h, oldw, oldh);
            Log.i("TAG", "width = " + getWidth() + "height = " + getHeight());
        }

5. 使用View.post()方法
   利用Handler通信机制，发送一个Runnable到MessageQueue中，当View布局处理完成时，自动发送消息，通知UI进程。借此机制，巧妙获取View的高宽属性，代码简洁，相比ViewTreeObserver监听处理，还不需要手动移除观察者监听事件。

        view.post(new Runnable() {
                @Override
                public void run() {
                    int width = view.getWidth();
                    int measuredWidth = view.getMeasuredWidth();
                    Log.i(TAG, "width: " + width);
                    Log.i(TAG, "measuredWidth: " + measuredWidth);
                }
            });


# 自定义View步骤

## 1. 自定义单一View

1. 继承现有的View类或其子类，如View、ImageView等。
2. 重写onMeasure()方法，在该方法中设定自定义View的宽高。
3. 重写onDraw()方法，在该方法中绘制自定义的View。Canvas决定要去画什么；Paint决定怎么画
4. 考虑支持自定义属性，通过重写构造方法并获取自定义属性值。在init方法中，可以初始化画笔、颜色、文本等属性。LayoutParams，
5. 如果需要响应用户的触摸事件、点击等操作，需要重写onTouchEvent()方法。
6. 注意调用invalidate()方法，触发重绘操作。

       public class MyCustomView extends View {
         public MyCustomView(Context context) {
            super(context);
        }
        public MyCustomView(Context context, AttributeSet attrs) {
            super(context, attrs);
        }
        public MyCustomView(Context context, AttributeSet attrs, int defStyleAttr) {
            super(context, attrs, defStyleAttr);
        }

        @Override
        public boolean onTouchEvent(MotionEvent event) {
        // 处理触摸事件
        switch (event.getAction()) {
           case MotionEvent.ACTION_DOWN:
           // 处理按下事件
           break;
           case MotionEvent.ACTION_MOVE:
            // 处理移动事件
            break;
            case MotionEvent.ACTION_UP:
            // 处理抬起事件
            break;
          }
           return true;
        }

        @Override
        protected void onDraw(Canvas canvas) {
            super.onDraw(canvas);
    
            // 在画布上绘制一个红色的矩形
            Paint paint = new Paint();
            paint.setColor(Color.RED);
            canvas.drawRect(0, 0, getWidth(), getHeight(), paint);
        }
        }

event.getX():表示的是触摸的点距离自身左边界的距离           
event.getY():表示的是触摸的点距离自身上边界的距离              
event.getRawX:表示的是触摸点距离屏幕左边界的距离             
event.getRawY:表示的是触摸点距离屏幕上边界的距离               
 
View.getWidth():表示的是当前控件的宽度，即getRight()-getLeft()       
View.getHeight()：表示的是当前控件的高度，即getBottom()-getTop()         
View.getTop():子View的顶部到父View顶部的距离         
View.getRight():子View的右边界到父View的左边界的距离       
View.getBottom():子View的底部到父View的顶部的距离       
View.getLeft():子View的左边界到父View的左边界的距离         
View.getTranslationX()计算的是该View在X轴的偏移量。初始值为0，向左偏移值为负，向右偏移值为正。       
View.getTranslationY()计算的是该View在Y轴的偏移量。初始值为0，向上偏移为负，向下偏移为证。     

注意：
1. `invalidate()`方法会触发`onDraw()`方法的调用，用于重绘自定义View的内容；          
2. `requestLayout()`方法会触发`onMeasure()`和`onLayout()`方法的调用，用于重新测量和布局自定义ViewGroup中的子View。            

## 2. 自定义ViewGroup：

1. 继承现有的ViewGroup类如LinearLayout、RelativeLayout等。
2. 重写onMeasure()方法，测量自定义ViewGroup及其子View的尺寸。
3. 重写onLayout()方法，指定子View的位置。
4. 考虑支持自定义属性，通过重写构造方法并获取自定义属性值。比如layoutParms等
5. 如果需要响应触摸事件、点击等操作，需要重写onTouchEvent()方法。
6. 注意子View的绘制顺序，可以使用getChildAt()和getChildCount()方法获取子View。

一般情况下，当自定义View需要处理触摸事件时，需要重写onTouchEvent()
方法。在该方法中可以根据MotionEvent的动作类型，如ACTION_DOWN、ACTION_MOVE、ACTION_UP等，执行相应的操作。

    public class MyCustomViewGroup extends ViewGroup {
    
        public MyCustomViewGroup(Context context) {
            super(context);
        }
    
        public MyCustomViewGroup(Context context, AttributeSet attrs) {
            super(context, attrs);
        }
    
        public MyCustomViewGroup(Context context, AttributeSet attrs, int defStyleAttr) {
            super(context, attrs, defStyleAttr);
        }
    
        @Override
        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
            // 测量ViewGroup的尺寸，需要考虑子View的大小及MeasureSpec
    
            // 测量子View的尺寸
            measureChildren(widthMeasureSpec, heightMeasureSpec);
    
            // 获取ViewGroup的宽度测量模式和大小
            int widthMode = MeasureSpec.getMode(widthMeasureSpec);
            int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    
            // 获取ViewGroup的高度测量模式和大小
            int heightMode = MeasureSpec.getMode(heightMeasureSpec);
            int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    
            // 计算ViewGroup的宽度
            int width = 0;
            if (widthMode == MeasureSpec.EXACTLY) {
                // 宽度测量模式为精确模式时，直接使用设置的宽度
                width = widthSize;
            } else {
                // 宽度测量模式为包裹内容或未指定模式时，计算所有子View的宽度总和作为ViewGroup的宽度
                for (int i = 0; i < getChildCount(); i++) {
                    View child = getChildAt(i);
                    width += child.getMeasuredWidth();
                }
            }
    
            // 计算ViewGroup的高度（取最高的子View的高度作为ViewGroup的高度）
            int height = 0;
            if (heightMode == MeasureSpec.EXACTLY) {
                // 高度测量模式为精确模式时，直接使用设置的高度
                height = heightSize;
            } else {
                // 高度测量模式为包裹内容或未指定模式时，取最高的子View的高度作为ViewGroup的高度
                for (int i = 0; i < getChildCount(); i++) {
                    View child = getChildAt(i);
                    height = Math.max(height, child.getMeasuredHeight());
                }
            }
    
            // 设置ViewGroup的测量结果
            setMeasuredDimension(width, height);
        }
    
        @Override
        protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
            // 对子View进行布局
    
            int childLeft = 0;
            int childTop = 0;
    
            // 遍历子View进行布局
            for (int i = 0; i < getChildCount(); i++) {
                View child = getChildAt(i);
    
                // 获取子View的宽度和高度
                int childWidth = child.getMeasuredWidth();
                int childHeight = child.getMeasuredHeight();
    
                // 布局子View
                child.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight);
    
                // 更新下一个子View的left值
                childLeft += childWidth;
            }
        }
    }

自定义ViewGroup不需要重写`onDraw()`方法。
因为`onDraw()`方法是用于在`View`上进行绘制操作的，而`ViewGroup`是一个容器，它的主要作用是管理子View的布局和绘制。
所以，在自定义ViewGroup中，我们主要需要重写`onMeasure()`方法来测量子View的尺寸，并重写`onLayout()`
方法来布局子View的位置。而对于绘制操作，通常会由子View自己负责。

# LinearLayout和RelativeLayout性能对比
RelativeLayout 会对子 View 做两次 measure。因为 RelativeLayout 中子 View 的排列方式是基于彼此的依赖关系，而这个依赖关系可能和布局中View的顺序并不相同，在确定每个子 View 的位置的时候，就需要先给所有的子View排序一下。所以需要横向纵向分别测量。

RelativeLayout会让子View调用2次onMeasure，而 LinearLayout 在没有 weight 时，只会调用1次onMeasure（如果 LinearLayout 有 weight 属性时，也会调用两次 onMeasure ）；因此LinearLayout 性能要高于 RelativeLayout 的性能，在实际操作时可以用 LinearLayout 完成，尽量用 LinearLayout 不去用 RelativeLayout 。       

# Android进程间通信（IPC）方式

1. 使用Bundle

我们都知道Android中三大组件Activity，Service，Receiver都支持在Intent中传递Bundle数据，而Bundle实现了Parcelable接口，所以它可以方便的在不同的进程间进行传输。
当我我们在一个进程中启动另外一个进程的Activity、Service、Receiver时，我们就可以在Bundle中附加我们所需要传输给远程进程的信息并通过intent发送出去。这里注意，我们传输的数据必须能够被序列化。
下面我们看一下利用Bundle进行进程间通信的例子：

      private void startWithIntent(){
         Intent intent = new Intent();
         //制定要打开的程序的包名(必须写全包名，不然会报错)和地址（activity名）
         intent.setComponent(new ComponentName("PackageName","PackageName.intentIpcActivity"));
         //通过budle传递数据，可以携带序列化数据
         Bundle bundle = new Bundle();
         bundle.putInt("intextra", 0);
         bundle.putString("stringextra", "测试数据");
         intent.putExtras(bundle);
         try{
            startActivity(intent);
         }catch(Exception e){
            ToastUtils.showMessage("没有找到对应文件");
         }
      }
      　　利用Bundle进行进程间通信是很容易的，大家应该也注意到，这种方式进行进程间通信只能是单方向的简单数据传输，它的使用有一定的局限性。

2. 使用文件共享
共享文件也是种不错的进程间通信的方式，两个进程通过读/写同一个文件来交换数据，比如A进程把数据写入文件FILE，B进程可以通过读取这个文件来获取这个数据。通过这种方式，除了可以交换简单的文本信息外，我们还可以序列化一个对象到文件系统中，另一个进程可以通过反序列化恢复这个对象。
比如A在进程中创建一个线程进行写数据

         new Thread(new Runnable(){
         @Override
         public void run(){
            User user = new User(1, "user", false);
            File cachedFile = new File(CACHE_FILE_PATH);
            ObjectOutputStream objectOutputStream = null;
            try{
               objectOutputStream = new ObjectOutputStream(new FileOutputStream(cachedFile));
               objectOutputStream.writeObject(user);
            }catch(IOException e){
               e.printStackTrace();
            }finally{
               objectOutputStream.close();
            }
            }
         }).start();

在B进程创建一个线程进行读取数据

         new Thread(new Runnable(){
         @Override
         public void run(){
            User user = null;
            File cachedFile = new File(CACHE_FILE_PATH);
            if (cachedFile.exists()){
               ObjectInputStream objectInputStream = null;
               try{
                  objectInputStream = new ObjectInputStream(new FileInputStream(cachedFile));
                  user = objectInputStream.readObject(user);
               } catch(IOException e){
                  e.printStackTrace();
               }finally{
                  objectInputStream.close();
               }
            }
            try{
               objectOutputStream = new ObjectOutputStream(new FileOutputStream(cachedFile));
               objectOutputStream.writeObject(user);
            }catch (IOException e){
               e,printStackTrace();
            }finally{
               objectOutputStream.close();
            }
         }
通过文件共享的这种方式来共享数据对文件的格式是没有具体要求的，比如可以是文本文件、也可以是XML文件，只要读写双方约定数据格式即可。这种方式进行进程间通信虽然方便，可是也是有局限性的，比如并发读/写，这会导致比较严重的问题，如读取的数据不完整或者读取的数据不是最新的。因此通过文件共享的方式适合在对数据同步要求不高的进程之间通信，并且要妥善处理并发读/写问题。

三、使用Messenger

Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，可以在不同进程中传递Messenger对象，在Messenger中放入我们需要传递的数据。它一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形。

Messenger的使用方法也是比较简单的，实现一个Messenger有如下几步，分为服务端和客户端：

服务端进程：在A进程创建一个Service来处理其他进程的连接请求，同时创建一个Handler并通过他来创建一个Messenger对象，然后在Service的onBind中返回这个Messneger对象底层的Binder即可。

      public class MessengerService extends Service {
      private static final String TAG = MessengerService.class.getSimpleName();

       private class MessengerHandler extends Handler {
           /**
            * @param msg
            */
           @Override
           public void handleMessage(Message msg) {
               switch (msg.what) {
                   case Constants.MSG_FROM_CLIENT:
                       Log.d(TAG, "receive msg from client: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]");
                       Toast.makeText(MessengerService.this, "receive msg from client: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]", Toast.LENGTH_SHORT).show();
                       Messenger client = msg.replyTo;
                       Message replyMsg = Message.obtain(null, Constants.MSG_FROM_SERVICE);
                       Bundle bundle = new Bundle();
                       bundle.putString(Constants.MSG_KEY, "我已经收到你的消息，稍后回复你！");
                       replyMsg.setData(bundle);
                       try {
                           client.send(replyMsg);
                       } catch (RemoteException e) {
                           e.printStackTrace();
                       }
                       break;
                   default:
                       super.handleMessage(msg);
               }
           }
       }

          private Messenger mMessenger = new Messenger(new MessengerHandler());
      
      
          @Nullable
          @Override
          public IBinder onBind(Intent intent) {
              return mMessenger.getBinder();
          }
      }
客户端进程：首先绑定服务端 Service ，绑定成功之后用服务端的 IBinder 对象创建一个 Messenger ，通过这个 Messenger 就可以向服务端发送消息了，消息类型是 Message 。如果需要服务端响应，则需要创建一个 Handler 并通过它来创建一个 Messenger（和服务端一样），并通过 Message 的 replyTo 参数传递给服务端。服务端通过 Message 的 replyTo 参数就可以回应客户端了。

      public class MainActivity extends AppCompatActivity {
      private static final String TAG = MainActivity.class.getSimpleName();
      private Messenger mGetReplyMessenger = new Messenger(new MessageHandler());
      private Messenger mService;

    //为了收到Service的回复，客户端需要创建一个接收消息的Messenger和Handler
    private class MessageHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            //消息处理
            switch (msg.what) {
                case Constants.MSG_FROM_SERVICE:
                    Log.d(TAG, "received msg form service: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]");
                    Toast.makeText(MainActivity.this, "received msg form service: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]", Toast.LENGTH_SHORT).show();
                    break;
                default:
                    super.handleMessage(msg);
            }
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

    }

    public void bindService(View v) {
        Intent mIntent = new Intent(this, MessengerService.class);
        bindService(mIntent, mServiceConnection, Context.BIND_AUTO_CREATE);
    }

    public void sendMessage(View v) {
        Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);
        Bundle data = new Bundle();
        data.putString(Constants.MSG_KEY, "Hello! This is client.");
        msg.setData(data);
        msg.replyTo = mGetReplyMessenger;
        try {
            mService.send(msg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }

    }

    @Override
    protected void onDestroy() {
        unbindService(mServiceConnection);
        super.onDestroy();
    }

    private ServiceConnection mServiceConnection = new ServiceConnection() {
        /**
         * @param name
         * @param service
         */
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            //根据得到的IBinder对象创建Messenger
            mService = new Messenger(service);
            //通过得到的mService 可以进行通信
            Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);
            Bundle data = new Bundle();
            data.putString(Constants.MSG_KEY, "Hello! This is client.");
            msg.setData(data);
            //
            msg.replyTo = mGetReplyMessenger;
            try {
                mService.send(msg);
            } catch (RemoteException e) {
                e.printStackTrace();
            }

        }

        /**
         * @param name
         */
        @Override
        public void onServiceDisconnected(ComponentName name) {

        }
         };
      }


Messenger内部消息处理使用Handler实现的，所以他是以串行的方式处理客户端发送过来的消息的，如果有大量的消息发送给服务端，服务端只能一个一个处理，如果并发量大的话用Messenger就不合适了，而且Messenger的主要作用是为了传递消息的，很多时候我们需要跨进程调用服务端的方法，这种需求Messenger就无法做到了。           

注意：客户端和服务端是通过拿到对方的 Messenger 来发送 Message 的。只不过客户端通过 bindService onServiceConnected 而服务端通过 message.replyTo 来获得对方的 Messenger 。Messenger 中有一个 Handler 以串行的方式处理队列中的消息。不存在并发执行，因此我们不用考虑线程同步的问题。           

4. 使用AIDL

AIDL (Android Interface Definition Language)是一种IDL语言，用于生成可以在Android设备上两个进程之间进行进程间通信(IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。
AIDL是IPC的一个轻量级实现，用了对于Java开发者来说很熟悉的语法。Android也提供了一个工具，可以自动创建Stub（类构架，类骨架）。当我们需要在应用间通信时，我们需要按以下几步走：

定义一个AIDL接口
为远程服务（Service）实现对应Stub
将服务“暴露”给客户程序使用
　　官方文档中对AIDL有这样一段介绍：Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. If you do not need to perform concurrent IPC across different applications, you should create your interface by implementing a Binder or, if you want to perform IPC, but do not need to handle multithreading, implement your interface using a Messenger. Regardless, be sure that you understand Bound Services before implementing an AIDL.

第一句最重要，“只有当你允许来自不同的客户端访问你的服务并且需要处理多线程问题时你才必须使用AIDL”，其他情况下你都可以选择其他方法，如使用Messager，也能跨进程通讯。可见AIDL是处理多线程、多客户端并发访问的。而Messager是单线程处理。

Messenger 是以串行的方式处理客户端发来的消息，如果大量消息同时发送到服务端，服务端只能一个一个处理，所以大量并发请求就不适合用 Messenger ，而且 Messenger 只适合传递消息，不能跨进程调用服务端的方法。AIDL 可以解决并发和跨进程调用方法的问题，要知道 Messenger 本质上也是 AIDL ，只不过系统做了封装方便上层的调用而已。

AIDL文件支持的数据类型

基本数据类型
String 和 CharSequence
ArrayList，里面的元素必须能够被AIDL支持；
HashMap，里面的元素必须能够被AIDL支持；
Parcelable，实现Parcelable接口的对象；注意：如果 AIDL 文件中用到了自定义的 Parcelable 对象，必须新建一个和它同名的 AIDL 文件。
AIDL。AIDL接口本身也可以在AIDL文件中使用。
AIDL很大的好处就是我们直接可以调用服务端进程所暴露出来的方法，下面简单介绍一下AIDL的使用：

服务端

服务端首先要创建一个Service用来监听客户端的请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可。

（1）创建AIDL接口文件

AIDL使用简单的语法来声明接口，描述其方法以及方法的参数和返回值。这些参数和返回值可以是任何类型，甚至是其他AIDL生成的接口。重要的是必须导入所有非内置类型，哪怕是这些类型是在与接口相同的包中。

      interface IRemoteService {
         int getPid();
         void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,double aDouble, String aString);
      }
（2）向客户端暴露接口

      public class DDService extends Service {
         @Override
         public void onCreate() {
            super.onCreate();
            System.out.println("DDService onCreate........" + "Thread: " + Thread.currentThread().getName());
         }

         @Override
         public IBinder onBind(Intent arg0) {
            System.out.println("DDService onBind");
            return mBinder;
         }

         private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {
           public int getPid(){
               System.out.println("Thread: " + Thread.currentThread().getName());
               System.out.println("DDService getPid ");
               return Process.myPid();
           }
         public void basicTypes(int anInt, long aLong, boolean aBoolean,float aFloat, double aDouble, String aString) {
               System.out.println("Thread: " + Thread.currentThread().getName());
               System.out.println("basicTypes aDouble: " + aDouble +" anInt: " + anInt+" aBoolean " + aBoolean+" aString " + aString);
           }
       };
      }


　　这样我们的服务端就完成了，把服务端运行到模拟器（或者手机上），等一会可以看一下打印信息，重点看“线程名”。

客户端

客户端所做的事情就要简单很多了，首先需要绑定服务端Service，绑定成功后将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。

客户端调用远程服务的方法，被调用的方法运行在服务端的 Binder 线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致 ANR 。客户端的 onServiceConnected 和 onServiceDisconnected 方法都在 UI 线程中。

      public class MainActivity extends Activity {
         private IRemoteService remoteService;
         @Override
         public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
      }

    ServiceConnection conn = new ServiceConnection() {
        @Override
        public void onServiceDisconnected(ComponentName name) {
        }
          
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            remoteService = IRemoteService.Stub.asInterface(service);
            try {
                int pid = remoteService.getPid();
                int currentPid = Process.myPid();
                System.out.println("currentPID: " + currentPid +"  remotePID: " + pid);
                remoteService.basicTypes(12, 1223, true, 12.2f, 12.3, "我们的爱，我明白");
            } catch (RemoteException e) {
                e.printStackTrace();
            }
            System.out.println("bind success! " + remoteService.toString());
        }
    };
          
    /**
     * 监听按钮点击
     * @param view
     */
    public void buttonClick(View view) {
        System.out.println("begin bindService");
        Intent intent = new Intent("duanqing.test.aidl");
        bindService(intent, conn, Context.BIND_AUTO_CREATE);
    }
  
    @Override
    protected void onDestroy() {
        super.onDestroy();
        unbindService(conn);
    }
      }

这样就实现了通过AIDL进行进程间通信了，是不是也很简单，不过这个看似简单，其实底层Android为我们做了很多的事情，核心就是Binder

5. 使用ContentProvider
ContentProvider（内容提供者）是Android中的四大组件之一，为了在应用程序之间进行数据交换，Android提供了ContentProvider，ContentProvider是不同应用之间进行数据交换的API，一旦某个应用程序通过ContentProvider暴露了自己的数据操作接口，那么不管该应用程序是否启动，其他应用程序都可以通过接口来操作接口内的数据，包括增、删、改、查等。ContentProvider分为系统的和自定义的，系统的也就是例如联系人，图片等数据。
开发一个ContentProvider的步骤很简单：
定义自己的ContentProvider类，该类继承ContentProvider基类；
在AndroidManifest.xml中注册这个ContentProvider，类似于Activity注册，注册时要给ContentProvider绑定一个域名；
当我们注册好ContentProvider后，其他应用就可以访问ContentProvider暴露出来的数据了。
ContentProvider只是暴露出来可供其他应用操作的数据，其他应用则需要通过ContentReslover来操作ContentProvider所暴露出来的数据。Context提供了getContentResolver()方法来获取ContentProvider对象，获取之后皆可以对暴露出来的数据进行增、删、改、查操作了。
使用ContentResolver操作数据的步骤也很简单：
调用Activity的getContentResolver()获取ContentResolver对象
根据调用的ContentResolver的insert()、delete()、update()、和query()方法操作数据库即可。
代码示例：

      
      public class BookProvider extends ContentProvider {
      private static final String TAG = "BookProvider";
      public static final String AUTHORITY = "com.jc.ipc.Book.Provider";

    public static final Uri BOOK_CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/book");
    public static final Uri USER_CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/user");

    public static final int BOOK_URI_CODE = 0;
    public static final int USER_URI_CODE = 1;
    private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);

    static {
        sUriMatcher.addURI(AUTHORITY, "book", BOOK_URI_CODE);
        sUriMatcher.addURI(AUTHORITY, "user", USER_URI_CODE);
    }

    private Context mContext;
    private SQLiteDatabase mDB;

    @Override
    public boolean onCreate() {
        mContext = getContext();
        initProviderData();

        return true;
    }

    private void initProviderData() {
        //不建议在 UI 线程中执行耗时操作
        mDB = new DBOpenHelper(mContext).getWritableDatabase();
        mDB.execSQL("delete from " + DBOpenHelper.BOOK_TABLE_NAME);
        mDB.execSQL("delete from " + DBOpenHelper.USER_TABLE_NAME);
        mDB.execSQL("insert into book values(3,'Android');");
        mDB.execSQL("insert into book values(4,'iOS');");
        mDB.execSQL("insert into book values(5,'Html5');");
        mDB.execSQL("insert into user values(1,'haohao',1);");
        mDB.execSQL("insert into user values(2,'nannan',0);");

    }

    @Nullable
    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
        Log.d(TAG, "query, current thread"+ Thread.currentThread());
        String table = getTableName(uri);
        if (table == null) {
            throw new IllegalArgumentException("Unsupported URI" + uri);
        }

        return mDB.query(table, projection, selection, selectionArgs, null, null, sortOrder, null);
    }

    @Nullable
    @Override
    public String getType(Uri uri) {
        Log.d(TAG, "getType");
        return null;
    }

    @Nullable
    @Override
    public Uri insert(Uri uri, ContentValues values) {
        Log.d(TAG, "insert");
        String table = getTableName(uri);
        if (table == null) {
            throw new IllegalArgumentException("Unsupported URI" + uri);
        }
        mDB.insert(table, null, values);
        // 通知外界 ContentProvider 中的数据发生变化
        mContext.getContentResolver().notifyChange(uri, null);
        return uri;
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        Log.d(TAG, "delete");
        String table = getTableName(uri);
        if (table == null) {
            throw new IllegalArgumentException("Unsupported URI" + uri);
        }
        int count = mDB.delete(table, selection, selectionArgs);
        if (count > 0) {
            mContext.getContentResolver().notifyChange(uri, null);
        }

        return count;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        Log.d(TAG, "update");
        String table = getTableName(uri);
        if (table == null) {
            throw new IllegalArgumentException("Unsupported URI" + uri);
        }
        int row = mDB.update(table, values, selection, selectionArgs);
        if (row > 0) {
            getContext().getContentResolver().notifyChange(uri, null);
        }
        return row;
    }

    private String getTableName(Uri uri) {
        String tableName = null;
        switch (sUriMatcher.match(uri)) {
            case BOOK_URI_CODE:
                tableName = DBOpenHelper.BOOK_TABLE_NAME;
                break;
            case USER_URI_CODE:
                tableName = DBOpenHelper.USER_TABLE_NAME;
                break;
            default:
                break;
        }

        return tableName;

    }
}

DBOpenHelper.java

      public class DBOpenHelper extends SQLiteOpenHelper {
      private static final String DB_NAME = "book_provider.db";
      public static final String BOOK_TABLE_NAME = "book";
      public static final String USER_TABLE_NAME = "user";

    private static final int DB_VERSION = 1;

    private String CREATE_BOOK_TABLE = "CREATE TABLE IF NOT EXISTS "
            + BOOK_TABLE_NAME + "(_id INTEGER PRIMARY KEY," + "name TEXT)";

    private String CREATE_USER_TABLE = "CREATE TABLE IF NOT EXISTS "
            + USER_TABLE_NAME + "(_id INTEGER PRIMARY KEY," + "name TEXT,"
            + "sex INT)";

    public DBOpenHelper(Context context) {
        super(context, DB_NAME, null, DB_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(CREATE_BOOK_TABLE);
        db.execSQL(CREATE_USER_TABLE);

    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    }
}
View Code

ProviderActivity.java

public class ProviderActivity extends AppCompatActivity {
private static final String TAG = ProviderActivity.class.getSimpleName();
private TextView displayTextView;
private Handler mHandler;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_provider);
        displayTextView = (TextView) findViewById(R.id.displayTextView);
        mHandler = new Handler();

        getContentResolver().registerContentObserver(BookProvider.BOOK_CONTENT_URI, true, new ContentObserver(mHandler) {
            @Override
            public boolean deliverSelfNotifications() {
                return super.deliverSelfNotifications();
            }

            @Override
            public void onChange(boolean selfChange) {
                super.onChange(selfChange);
            }

            @Override
            public void onChange(boolean selfChange, Uri uri) {
                Toast.makeText(ProviderActivity.this, uri.toString(), Toast.LENGTH_SHORT).show();
                super.onChange(selfChange, uri);
            }
        });


    }

    public void insert(View v) {
        ContentValues values = new ContentValues();
        values.put("_id",1123);
        values.put("name", "三国演义");
        getContentResolver().insert(BookProvider.BOOK_CONTENT_URI, values);

    }
    public void delete(View v) {
        getContentResolver().delete(BookProvider.BOOK_CONTENT_URI, "_id = 4", null);


    }
    public void update(View v) {
        ContentValues values = new ContentValues();
        values.put("_id",1123);
        values.put("name", "三国演义新版");
        getContentResolver().update(BookProvider.BOOK_CONTENT_URI, values , "_id = 1123", null);


    }
    public void query(View v) {
        Cursor bookCursor = getContentResolver().query(BookProvider.BOOK_CONTENT_URI, new String[]{"_id", "name"}, null, null, null);
        StringBuilder sb = new StringBuilder();
        while (bookCursor.moveToNext()) {
            Book book = new Book(bookCursor.getInt(0),bookCursor.getString(1));
            sb.append(book.toString()).append("\n");
        }
        sb.append("--------------------------------").append("\n");
        bookCursor.close();

        Cursor userCursor = getContentResolver().query(BookProvider.USER_CONTENT_URI, new String[]{"_id", "name", "sex"}, null, null, null);
        while (userCursor.moveToNext()) {
            sb.append(userCursor.getInt(0))
                    .append(userCursor.getString(1)).append(" ,")
                    .append(userCursor.getInt(2)).append(" ,")
                    .append("\n");
        }
        sb.append("--------------------------------");
        userCursor.close();
        displayTextView.setText(sb.toString());
    }
}
View Code

6. 使Socket

Socket也是实现进程间通信的一种方式，Socket也成为“套接字”，是网络通信中的概念，通过Socket我们可以很方便的进行网络通信，都可以实现网络通信录，那么实现跨进程通信不是也是相同的么。
Socket起源于 Unix，而 Unix 基本哲学之一就是“一切皆文件”，都可以用“打开 open –读写 write/read –关闭 close ”模式来操作。Socket 就是该模式的一个实现，网络的 Socket 数据传输是一种特殊的 I/O，Socket 也是一种文件描述符。Socket 也具有一个类似于打开文件的函数调用： Socket()，该函数返回一个整型的Socket 描述符，随后的连接建立、数据传输等操作都是通过该 Socket 实现的。
常用的 Socket 类型有两种：流式 Socket（SOCK_STREAM）和数据报式 Socket（SOCK_DGRAM）。流式是一种面向连接的 Socket，针对于面向连接的 TCP 服务应用；数据报式 Socket 是一种无连接的 Socket ，对应于无连接的 UDP 服务应用。
Socket 本身可以传输任意字节流。
谈到Socket，就必须要说一说 TCP/IP 五层网络模型：

应用层：规定应用程序的数据格式，主要的协议 HTTP，FTP，WebSocket，POP3 等；
传输层：建立“端口到端口” 的通信，主要的协议：TCP，UDP；
网络层：建立”主机到主机”的通信，主要的协议：IP，ARP ，IP 协议的主要作用：一个是为每一台计算机分配 IP 地址，另一个是确定哪些地址在同一子网；
数据链路层：确定电信号的分组方式，主要的协议：以太网协议；
物理层：负责电信号的传输。
Socket 是连接应用层与传输层之间接口（API）。

只实现 TCP Socket 。

Client 端代码：

public class TCPClientActivity extends AppCompatActivity implements View.OnClickListener{
private static final String TAG = "TCPClientActivity";
public static final int MSG_RECEIVED = 0x10;
public static final int MSG_READY = 0x11;
private EditText editText;
private TextView textView;
private PrintWriter mPrintWriter;
private Socket mClientSocket;
private Button sendBtn;
private StringBuilder stringBuilder;
private Handler mHandler = new Handler(){
@Override
public void handleMessage(Message msg) {
switch (msg.what) {
case MSG_READY:
sendBtn.setEnabled(true);
break;
case MSG_RECEIVED:
stringBuilder.append(msg.obj).append("\n");
textView.setText(stringBuilder.toString());
break;
default:
super.handleMessage(msg);
}

    }
    };

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.tcp_client_activity);
        editText = (EditText) findViewById(R.id.editText);
        textView = (TextView) findViewById(R.id.displayTextView);
        sendBtn = (Button) findViewById(R.id.sendBtn);
        sendBtn.setOnClickListener(this);
        sendBtn.setEnabled(false);
        stringBuilder = new StringBuilder();

        Intent intent = new Intent(TCPClientActivity.this, TCPServerService.class);
        startService(intent);

        new Thread(){
            @Override
            public void run() {
                connectTcpServer();
            }
        }.start();
    }


    private String formatDateTime(long time) {
        return new SimpleDateFormat("(HH:mm:ss)").format(new Date(time));
    }

    private void connectTcpServer() {
        Socket socket = null;
        while (socket == null) {
            try {
                socket = new Socket("localhost", 8888);
                mClientSocket = socket;
                mPrintWriter = new PrintWriter(new BufferedWriter(
                        new OutputStreamWriter(socket.getOutputStream())
                ), true);
                mHandler.sendEmptyMessage(MSG_READY);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        // receive message
        BufferedReader bufferedReader = null;
        try {
            bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        } catch (IOException e) {
            e.printStackTrace();
        }
        while (!isFinishing()) {
            try {
                String msg = bufferedReader.readLine();
                if (msg != null) {
                    String time = formatDateTime(System.currentTimeMillis());
                    String showedMsg = "server " + time + ":" + msg
                            + "\n";
                    mHandler.obtainMessage(MSG_RECEIVED, showedMsg).sendToTarget();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

        }
    }

    @Override
    public void onClick(View v) {
        if (mPrintWriter != null) {
            String msg = editText.getText().toString();
            mPrintWriter.println(msg);
            editText.setText("");
            String time = formatDateTime(System.currentTimeMillis());
            String showedMsg = "self " + time + ":" + msg + "\n";
            stringBuilder.append(showedMsg);

        }

    }

    @Override
    protected void onDestroy() {
        if (mClientSocket != null) {
            try {
                mClientSocket.shutdownInput();
                mClientSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        super.onDestroy();
    }
}
Server端代码：

public class TCPServerService extends Service {
private static final String TAG = "TCPServerService";
private boolean isServiceDestroyed = false;
private String[] mMessages = new String[]{
"Hello! Body!",
"用户不在线！请稍后再联系！",
"请问你叫什么名字呀？",
"厉害了，我的哥！",
"Google 不需要Science上网是真的吗？",
"扎心了，老铁！！！"
};


    @Override
    public void onCreate() {
        new Thread(new TCPServer()).start();
        super.onCreate();
    }

    @Override
    public void onDestroy() {
        isServiceDestroyed = true;
        super.onDestroy();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    private class TCPServer implements Runnable {
        @Override
        public void run() {
            ServerSocket serverSocket = null;
            try {
                serverSocket = new ServerSocket(8888);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }
            while (!isServiceDestroyed) {
                // receive request from client
                try {
                    final Socket client = serverSocket.accept();
                    Log.d(TAG, "=============== accept ==================");
                    new Thread(){
                        @Override
                        public void run() {
                            try {
                                responseClient(client);
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    }.start();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

        }
    }


    private void responseClient(Socket client) throws IOException {
        //receive message
        BufferedReader in = new BufferedReader(
                new InputStreamReader(client.getInputStream()));
        //send message
        PrintWriter out = new PrintWriter(
                new BufferedWriter(
                        new OutputStreamWriter(
                                client.getOutputStream())),true);
        out.println("欢迎来到聊天室！");

        while (!isServiceDestroyed) {
            String str = in.readLine();
            Log.d(TAG, "message from client: " + str);
            if (str == null) {
                return;
            }
            Random random = new Random();
            int index = random.nextInt(mMessages.length);
            String msg = mMessages[index];
            out.println(msg);
            Log.d(TAG, "send Message: " + msg);
        }
        out.close();
        in.close();
        client.close();

    }
}
